#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Node{
	int key;
	char color;
	struct Node *left, *right, *parent;
}Node;

Node *NIL;

void init_nil();

Node * newNode(int key, char color, Node *parent);

int isBlack(Node *root);

int doubleRed(Node *root);

int doubleBlack(Node *root);

Node * sibling(Node *root);



Node * search(Node *root, int key);



Node * insert(Node *root, int key); // can implement insert func using recursive.

void restructure(Node **root, Node *z);

void leftRotate(Node **root, Node *x);

void rightRotate(Node **root, Node *x);

Node * recolor(Node *z); // return new z(need to check double red again);



Node * findMin(Node *root);

Node * delete(Node *root, int key);

void transfer(Node **root, Node *y);

Node * fusion(Node *y);



void inorder(Node *root);



int main(int argc, char* argv[]){
	init_nil();
	Node *root = NIL;
	do{
		int temp;
		printf("1: INSERT   2: DELETE   3: PRINT(INORDER)   4: QUIT\n");
		printf("Enter > ");
		scanf("%d", &temp);
		
		if (temp == 4){
			break;
		}
		else if (temp == 1){
			int key;
			printf("Enter Key Number(INT) > ");
			scanf("%d", &key);

			root = insert(root, key);
		}
		else if (temp == 2){
			int key;
			printf("Enter Key Number(INT) > ");
			scanf("%d", &key);

			root = delete(root, key);
		}
		else if (temp == 3){
			inorder(root);
			printf("\n");
		}
	}while (1);
	return 0;
}

void init_nil(){
	NIL = (Node*)malloc(sizeof(Node));
	NIL->color = 'b';
	NIL->left = NIL->right = NIL->parent = NIL;
}

Node * newNode(int key, char color, Node *parent){
	Node *node = (Node*)malloc(sizeof(Node));
	node->left = node->right = NIL;
	node->parent = parent;
	node->key = key;
	node->color = color;
	return node;
}

int isBlack(Node *root){
	return (root->color == 'b');
}

int doubleRed(Node *root){
	return (!isBlack(root) && !isBlack(root->parent));
}

Node * sibling(Node *root){
	if (root->parent->left == root)
		return root->parent->right;
	else
		return root->parent->left; // include the case that parent is null = sibling's null too.
}

Node * search(Node *root, int key){
	while (root != NIL && key != root->key){
		if (key < root->key) root = root->left;
		else if (key > root->key) root = root->right;
	}
	return root; // can't find or root is nil -> NIL, find -> Node *
}

Node * insert(Node *root, int key){ // first. insert new node.
	if (root == NIL)
		return newNode(key, 'b', NIL);  // the root is NIL.
	
	Node *p = NIL, *t = root;
	while (t != NIL && key != t->key){
		p = t;
		if (key < t->key) t = t->left;
		else if (key > t->key) t = t->right;
	}
	if (t != NIL) return root; // the key already exists.

	Node *n = newNode(key, 'r', p);
	if (key < p->key)
		p->left = n;
	else
		p->right = n;
	
	// second. adjust double red	
	while (doubleRed(n)){
		Node *uncle = sibling(n->parent);
		if (isBlack(uncle)){
			//  restructure
			restructure(&root, n);
			return root;
		}
		else{
			n = recolor(n);
		}
	}
	return root;
}

void restructure(Node **root, Node *z){
	Node *p = z->parent;
	Node *gp = p->parent;
	if (gp->left == p){
		if (p->left == z){
			// LL
			rightRotate(root, gp);
			p->color = 'b';
			gp->color = 'r';
		}
		else{
			leftRotate(root, p);
			rightRotate(root, gp);
			z->color = 'b';
			gp->color = 'r';
		}
	}
	else{
		if (p->right == z){
			// RR
			leftRotate(root, gp);
			p->color = 'b';
			gp->color = 'r';
		}
		else{
			// RL
			rightRotate(root, p);
			leftRotate(root, gp);
			z->color = 'b';
			gp->color = 'r';
		}
	}
}

void leftRotate(Node **root, Node *x){
	Node *y = x->right;
  x->right = y->left;
  if (y->left != NIL) y->left->parent = x;

  y->parent = x->parent;
  if (x->parent == NIL)
      *root = y;
  else if (x == x->parent->left)
      x->parent->left = y;
  else
      x->parent->right = y;

  y->left = x;
  x->parent = y;
}

void rightRotate(Node **root, Node *x){
	Node *y = x->left;
  x->left = y->right;
  if (y->right != NIL) y->right->parent = x;

  y->parent = x->parent;
  if (x->parent == NIL)
      *root = y;
  else if (x == x->parent->left)
      x->parent->left = y;
  else
      x->parent->right = y;

  y->right = x;
  x->parent = y;
}

Node * recolor(Node *z){
	z->parent->color = sibling(z->parent)->color = 'b';
	if (z->parent->parent->parent != NIL) z->parent->parent->color = 'r';
	return z->parent->parent;
}


Node * findMin(Node *root){
	while (root->left != NIL) root = root->left;
	return root;
}


Node * delete(Node *root, int key){
	// delete node check -> double black check -> delete -> adjustment
	Node *v = search(root, key);
	if (v == NIL) return root;

	if (v->left != NIL && v->right != NIL){
		Node *post = findMin(v->right);
		v->key = post->key;
		v = post;
	} // if the deleted node has children, find Min..

	Node *child;
	if (v->left != NIL) child = v->left;
	else child = v->right;
	// judge if the case is 0 (Not a double Black)
	// simple case! => color child black and return root
	if ( !isBlack(v) || !isBlack(child) ){
		if (v->parent == NIL){
			root = child;
			if (child != NIL) child->parent = NIL;
		}
		else{
			if (v->parent->left == v) v->parent->left = child;
			else v->parent->right = child;
			if (child != NIL) child->parent = v->parent;
		}
		if (child != NIL) child->color = 'b';
		free(v);
		return root;
	}

	// v and child are all black! -> case 1, 2, 3
	if (v->parent == NIL){
		root = child;
		if (child != NIL) child->parent = NIL;
		free(v);
		return root;
	}
	else{
		if (v->parent->left == v) v->parent->left = child;
		else v->parent->right = child;
		if (child != NIL) child->parent = v->parent;
	}

	Node *r = child;
	Node *p = v->parent;
	free(v);

	// third. adjustment case 1, 2, 3
	while (r != root && isBlack(r)){
		Node *sib;
		if (p->left == r) sib = p->right;
		else sib = p->left;

		if ( !isBlack(sib) ){  // case 3
			if (p->left == sib){
				rightRotate(&root, p);
				sib->color = 'b';
				p->color = 'r';
				// BE CAREFUL!
				sib = p->left;
			}
			else{
				leftRotate(&root, p);
				sib->color = 'b';
				p->color = 'r';
				// BE CAREFUL!
				sib = p->right;
			}
		}

		if (!isBlack(sib->left) || !isBlack(sib->right)){  // case 1
			transfer(&root, sib);
			return root;
		}
		else{  // case 2
			if (!isBlack(p)){
				fusion(sib);
				break;
			}
			r = fusion(sib);
			p = r->parent;
		}
	}
	return root;
}

void transfer(Node **root, Node *y){
	Node *pp = y->parent;
	Node *z;
	if (!isBlack(y->left))
		z = y->left;
	else
		z = y->right;
	
	if (pp->left == y){
		if (y->left == z){
			rightRotate(root, pp);
			y->color = pp->color;
			z->color = pp->color = 'b';
		}
		else{
			leftRotate(root, y);
			rightRotate(root, pp);
			z->color = pp->color;
			y->color = pp->color = 'b';
		}
	}
	else{
		if (y->right == z){
			leftRotate(root, pp);
			y->color = pp->color;
			z->color = pp->color = 'b';
		}
		else{
			rightRotate(root, y);
			leftRotate(root, pp);
			z->color = pp->color;
			y->color = pp->color = 'b';
		}
	}
}

Node * fusion(Node *y){
	y->color = 'r';
	y->parent->color = 'b';
	return y->parent;
}


void inorder(Node *root){
	if (root == NIL) return;
	if (root->left != NIL) inorder(root->left);
	
	if (root->color == 'b') printf("%db ", root->key);
	else printf("%dr ", root->key);
	if (root->right != NIL) inorder(root->right);
}
