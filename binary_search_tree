#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Binary Search Tree doesn't permit the same key. But we can make the tree permit.

typedef struct bst{
        int key;
        struct bst* left;
        struct bst* right;
}Bst;

Bst* search(Bst* r, int x);

Bst* newNode(int x);

Bst* insert(Bst* r, int x);

Bst* delete(Bst* r, int x);

Bst* findMin(Bst* r);

void destroy(Bst* r);

void preorder(Bst *r);

void inorder(Bst* r);

void postorder(Bst* r);

int main(int argc, char* argv[]){
        int n;
        printf("Input Size: ");
        scanf("%d", &n);

        int i;
        srand(time(NULL));
        int* ary = (int*)malloc(sizeof(int)*n);
        ary[0] = rand() % 100;
        Bst* root = newNode(ary[0]);
        for (i=1; i<n; i++){
                ary[i] = rand() % 100;
                root = insert(root, ary[i]);
        }

        printf("Insert Order..\n");
        for (i=0; i<n; i++){
                printf("%d ", ary[i]);
        }
        printf("\n\n");

        printf("Preorder\n");
        preorder(root);
        printf("\n\n");

        printf("Inorder\n");
        inorder(root);
        printf("\n\n");

        printf("Postorder\n");
        postorder(root);
        printf("\n");

        free(ary);
        destroy(root);

        return 0;
}



Bst* search(Bst* r, int x){
        if (r==NULL || r->key  == x) return r;
        else if (x < r->key) return search(r->left, x);
        else return search(r->right, x);
}

Bst* newNode(int x){
        Bst* node = (Bst*)malloc(sizeof(Bst));
        node->key = x;
        node->left = NULL;
        node->right = NULL;

        return node;
}

Bst* insert(Bst* r, int x){
        if (r == NULL)
                return newNode(x);
        else if (x < r->key) r->left = insert(r->left, x);
        else r->right = insert(r->right, x);
        return r;
}

Bst* findMin(Bst* r){
        while (r->left != NULL)
                r = r->left;
        return r;
}

// We deny the case that doesn't have the x in tree.
Bst* delete(Bst* r, int x){
        if (r == NULL) return NULL;

        if (x < r->key) r->left = delete(r->left, x);
        else if (x > r->key) r->right = delete(r->right, x);
        else if (x == r->key){
                if (r->left == NULL && r->right == NULL){
                        free(r);                                              return NULL;
                }
                else if (r->left == NULL || r->right == NULL){
                        Bst* t;
                        if (r->left == NULL)
                                t = r->right;
                        else
                                t = r->left;
                        free(r);
                        return t;
                }
                else{
                        Bst* min = findMin(r->right);
                        r->key = min->key;
                        r->right = delete(r->right, min->key);
                }
        }
        return r;
}

void preorder(Bst* r){
        if (r == NULL) return;
        printf("%d ", r->key);
        if (r->left != NULL)
                preorder(r->left);
        if (r->right != NULL)
                preorder(r->right);
}

void inorder(Bst* r){
        if (r == NULL) return;
        if (r->left != NULL)
                inorder(r->left);
        printf("%d ", r->key);
        if (r->right != NULL)
                inorder(r->right);
}

void postorder(Bst* r){
        if (r == NULL) return;
        if (r->left != NULL)
                postorder(r->left);
        if (r->right != NULL)
                postorder(r->right);
        printf("%d ", r->key);
}

void destroy(Bst* r){
        while (r != NULL){
                r = delete(r, r->key);
        }
}
